# Теория по библиотеке Customtkinter 
--------------------------------------------------------------------------------
## Создание главного окна
Главное окно приложения можно создать при помощи класса **CTK()**. Также вы можете задавать для него некоторые свойства:

- размеры окна задаются в пикселях при помощи метода **geometry()**;
- заголовок окна можно изменять при помощи метода **title()**;
- цвет фона вы также можете изменить, используя параметр **fg_color** в методе **configure()**.

Пример:
```
root = ctk.CTk()
root.geometry('1200x700')
root.title('Название приложения')
root.configure(fg_color='lightgreen')
```

--------------------------------------------------------------------------------
## Создание простейших виджетов в главном окне
В главном окне можно создавать и размещать различные интерактивные элементы - тектовые поля, надписи, кнопки и т.д. Все эти элементы называются **виджетами**.

Виджеты в customtkinter создаются при помощи специальных классов, внутри которых указывается окно для размещения виджета в параметре **master**, а свойства для каждого виджета задаются в методе **configure()** с использованием некоторых параметров. Рассмотрим классы для создания простейших виджетов:

--------------------------------------------------------------------------------

1. Класс **CTkButton()** - используется для создания кнопки. Основные параметры:
- **text** - надпись на кнопке;
- **font** - шрифт;
- **fg_color** - цвет кнопки;
- **hover_color** - цвет кнопки при наведении курсора;
- **text_color** - цвет надписи на кнопке;
- **command** - функция, которая выполняется при нажатии на кнопку;
- **cursor** - форма курсора при наведении на кнопку (arrow - стрелка, cross - крестик, wait - знак ожидания, hand2 - классический);
и другие.

Пример создания кнопки:
```
btn = ctk.CTkButton(master=root)
btn.configure(text='Моя кнопка', command=check, font=my_font, fg_color='yellow', text_color='black', hover_color='orange', cursor='cross')
```

Шрифт можно создать при помощи класса **CTkFont()**. Дополннительные параметры - **weight** для жирного шрифта и **slant** для курсива:
```
my_font = font=ctk.CTkFont(family='Courier', size=20, weight='bold', slant='italic)
```

--------------------------------------------------------------------------------

2. Класс **CTkLabel()** - используется для создания надписей (тектовых меток) в окне. Основные параметры:
- **text** - текст надписи;
- **font** - шрифт;
- **text_color** - цвет шрифта;
и другие.

Пример создания надписи:
```
lbl = ctk.CTkLabel(master=root)
lbl.configure(text='Моя надпись', font=my_font, text_color='white')
```

--------------------------------------------------------------------------------

3. Класс **CTkEntry()** - используется для создания поля для ввода/вывода текста. Основные параметры:
- **font** - шрифт;
- **text_color** - цвет текста в поле для ввода;
- **justify** - расположение текста в поле (center - по центру, right - по правому краю, left - по левому краю);
- **state** - равен 'normal', если в поле можно вводить текст и изменять его, и 'disabled', если поле нельзя изменить;
и другие.

Пример создания текстового поля:
```
entr = ctk.CTkEntry(master=root)
entr.configure(justify='center', state='normal', font=my_font, text_color='darkblue')
```

Некоторые методы текстового поля:

- метод **get()** - позволяет сохранить значение из поля в какую-нибудь переменную (пример: _s = entr.get()_ - для текста, _d = int(entr.get())_ - для целых чисел);
- метод **delete()** - позволяет удалить текст из тектового поля по заданным позициям (пример: _entr.delete(0, 'end')_ - очистка всего текста из поля полностью);
- метод **insert()** - вставляет новое значение в тектовое поле (пример: _entr.insert(0, 'новый текст')_).

--------------------------------------------------------------------------------
## Размещение виджетов в главном окне
Элементы в главном окне размещаются при помощи метода **grid()**, в котором указывается номер строки и номер столбца - позиция ячейки, где виджет будет расположен. **Grid** разбивает окно на столбцы и строки, которые сужаются до минимума, когда они пусты, но адаптируются к размеру размещенных внутри них виджетов.

Сделаем так, чтобы наше окно состояло из 7 строк и 7 столбцов. Для этого каждой строке и каждому столбцу нужно задать "вес", равный единице:

```
r, c = 7, 7
for i in range(r):
    root.rowconfigure(i, weight=1)
for i in range(c):
    root.columnconfigure(i, weight=1)
```

Теперь мы можем располагать виджеты так, как нам удобно, при помощи метода **grid()**. Например, давайте создадим обычную кнопку и расположим её посередине окна, то есть в 3 строке и в 3 столбце:

```
btn = ctk.CTkButton(master=root)
btn.configure(text='Моя кнопка', command=check, font=my_font)
btn.grid(row=3, column=3, padx=10, pady=10, sticky='ew')
```

Параметр **row** отвечает за номер строки, **column** - за номер столбца. Параметры **padx** и **pady** задают отступы от элементов в соседних ячейках в пикселях. Параметр **sticky** растягивает виджеты по размеру ячейки('ns' - растяжение вверх и вниз, 'ew' - растяжене вправо и влево, 'nsew' - вовсе стороны).

--------------------------------------------------------------------------------
## Выпадающие списки
Помимо кнопок, текстовых меток и текстовых полей, в главном окне можно создавать и другие более сложные интерактивные элементы.

Рассмотрим классы для создания выпадающих списков:

--------------------------------------------------------------------------------

1. Класс **CTkComboBox()** - используется для создания выпадающего списка. Вы можете выбирать элементы списка или вводить собственные значения в поле списка. Основные параметры:
- **values** - список элементов (строк), которые будут в выпадающем списке;
- **font** - шрифт;
- **fg_color** - цвет фона поля ввода;
- **dropdown_fg_color** - цвет фона выпадающего списка;
- **dropdown_font** - шрифт для элементов выпадающего списка;
- **button_color** - цвет кнопки-стрелки для открытия списка;
- **hover_color** - цвет кнопки-стрелки при наведении курсора;
- **text_color** - цвет надписи на выпадающем списке;
- **justify** - выравнивание (расположение) текста на выпадающем списке ('left', 'right', 'center');
- **state** - состояние списка (_normal_ - можно ввести своё значение или выбрать из списка; _readonly_ - нельзя вводить своё значение, но можно выбрать уже существующие; _disabled_ - списком невозможно воспользоваться);
- **command** - функция, которая выполняется при выборе нового элемента в списке (при создании функции учитывайте, что у неё есть аргумент, который нужно указать в скобках в её заголовке, - этот аргумент является выбранным элементом списка)

и другие.

**Важно!** Все эти параметры не являются обязательными, то есть их не всегда нужно использовать. Например, если в вашем приложении действие происходит при нажатии на кнопку, а не при выборе значения в списке, то параметр command указывать не нужно - он уже будет в свойствах кнопки. Или если вы хотите оставить для списка классическое оформление, то не нужно указывать все параметры для цветов: fg_color, button_color и т. д.

Пример создания выпадающего списка для простейшего калькулятора:
```
operations = ["Сложение", "Вычитание", "Умножение", "Деление"]
cmb = ctk.CTkComboBox(master=root)
cmb.configure(justify="center", values=operations, state="readonly", font=my_font, command=choice)
```

Некоторые методы выпадающего списка:
- метод **get()** - позволяет получить значение, выбранное в выпадающем списке, и либо сохранить его в какую-нибудь переменную, либо сравнить с каким-либо значением (пример: _s = cmb.get()_ - сохранение, _if cmb.get() == '...'_ - проверка на конкретное значение);
- метод **set()** - позволяет установить в списке значение по умолчанию, то есть это то значение, которое отобразится в списке при запуске программы (если не используете данный метод, при запуске в списке будет надпись CTkComboBox).

Пример использования set() для простейшего калькулятора (см. выше):
```
cmb.set("Сложение")
```

--------------------------------------------------------------------------------
2. Класс **CTkOptionMenu()** - также используется для создания выпадающего списка, но без возможности вводить в поле собственные значения. Вы можете только выбирать уже существующие элементы списка. Основные параметры:
- **values** - список элементов (строк), которые будут в выпадающем списке;
- **font** - шрифт;
- **fg_color** - цвет фона поля ввода;
- **dropdown_fg_color** - цвет фона выпадающего списка;
- **dropdown_font** - шрифт для элементов выпадающего списка;
- **button_color** - цвет кнопки-стрелки для открытия списка;
- **hover_color** - цвет кнопки-стрелки при наведении курсора;
- **text_color** - цвет надписи на выпадающем списке;
- **anchor** - выравнивание (расположение) текста на выпадающем списке (_'w'_ - по левому краю, _'e'_ - по правому краю, _'center'_ - по центру);
- **state** - состояние списка (_normal_ - можно ввести своё значение или выбрать из списка; _readonly_ - нельзя вводить своё значение, но можно выбрать уже существующие; _disabled_ - списком невозможно воспользоваться);
- **command** - функция, которая выполняется при выборе нового элемента в списке (при создании функции учитывайте, что у неё есть аргумент, который нужно указать в скобках в её заголовке, - этот аргумент является выбранным элементом списка)

и другие.

**Важно!** Все эти параметры не являются обязательными, то есть их не всегда нужно использовать. Например, если в вашем приложении действие происходит при нажатии на кнопку, а не при выборе значения в списке, то параметр command указывать не нужно - он уже будет в свойствах кнопки. Или если вы хотите оставить для списка классическое оформление, то не нужно указывать все параметры для цветов: fg_color, button_color и т. д.

Пример создания выпадающего списка для дней недели:
```
days = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"]
week_menu = ctk.CTkOptionMenu(master=root)
week_menu.configure(values=days, font=my_font, command=choice, anchor='center', text_color='black', fg_color='mediumaquamarine', button_color='mediumseagreen')
```

Некоторые методы выпадающего списка:
- метод **get()** - позволяет получить значение, выбранное в выпадающем списке, и либо сохранить его в какую-нибудь переменную, либо сравнить с каким-либо значением (пример: _s = week_menu.get()_ - сохранение, _if week_menu.get() == '...'_ - проверка на конкретное значение);
- метод **set()** - позволяет установить в списке значение по умолчанию, то есть это то значение, которое отобразится в списке при запуске программы (если не используете данный метод, при запуске в списке будет надпись CTkOptionMenu).

Пример использования set() для списка с днями недели (см. выше):
```
week_menu.set("Дни недели")
```

--------------------------------------------------------------------------------
## О параметре command
**command** — это параметр, который позволяет привязать какие-либо действия к виджету (например, к кнопке или к выпадающему списку). Эти действия прописываются в функции, которая автоматически вызывается, когда происходит определенное событие (для выпадающих списков — когда пользователь выбирает элемент, для кнопок - когда пользователь нажимает на кнопку).

Как это работает для разных виджетов:

1. **CTkButton** - функция срабатывает при нажатии на кнопку:
```
import customtkinter as ctk

def press():
    print("Кнопка была нажата!")  # Здесь можно выполнить любое другое действие: обновить другие виджеты, изменить цвет фона, изменить данные в текстовом поле и т.д.

root = ctk.CTk()

button = ctk.CTkButton(master=root)
button.configure(text="Нажми меня", command=press)  # функция press вызывается при нажатии
button.grid(row=0, column=0, padx=10, pady=10, sticky='ew')

root.mainloop()
```

2. **CTkOptionMenu** - функция сработает при выборе элемента из списка:
```
import customtkinter as ctk

def menu_func(choice):
    print(f"Пользователь выбрал: {choice}")  # Здесь можно выполнить любые другие действия: обновить другие виджеты, изменить цвет фона, изменить данные в текстовом поле и т.д.

root = ctk.CTk()

option_menu = ctk.CTkOptionMenu(master=root)
option_menu.configure(values=["Красный", "Зеленый", "Синий"], command=menu_func)  # функция menu_func получит выбранное в списке значение
option_menu.grid(row=0, column=0, padx=10, pady=10, sticky='ew')

root.mainloop()
```

3. **CTkComboBox** - функция также сработает при выборе элемента из списка, но не сработает, если пользователь введёт своё значение:
```
import customtkinter as ctk

def cmb_func(choice):
    print(f"Пользователь выбрал: {choice}")  # Здесь можно выполнить любые другие действия: обновить другие виджеты, изменить цвет фона, изменить данные в текстовом поле и т.д.

root = ctk.CTk()

cmb = ctk.CTkOptionMenu(master=root)
cmb.configure(values=["Красный", "Зеленый", "Синий"], command=cmb_func)  # функция cmb_func получит выбранное в списке значение
cmb.grid(row=0, column=0, padx=10, pady=10, sticky='ew')

root.mainloop()
```
--------------------------------------------------------------------------------
Программа для сравнения классов **CTkComboBox** и **CTkOptionMenu**: https://github.com/alekseewatatianawork73/Python-first-year/blob/main/ctk_optionmenu_combobox.py 

--------------------------------------------------------------------------------
## Удаление виджетов

**1. Метод destroy()** - полное удаление виджета. Этот метод удаляет без возможности восстановления, т. е. виджет больше нельзя будет отобразить - он исчезнет из памяти полнстью. Если захотите его вернуть, придётся создавать заново.

Пример:
```
...
lbl.destroy()  # удаляем надпись lbl из окна
...
lbl.grid(row=0, column=0)  # через некоторое время пытаемся вернуть
=> ошибка: bad window path name - такого виджета больше не существует!
```

**2. Метод grid_forget()** - не удаляет виджет полностью, а всего лишь скрывает его на время. После применения виджет не будет отображаться в окне, но всё ещё будет существовать в памяти => его можно будет отобразить снова.

Пример:
```
...
lbl.grid_forget()  # удаляем надпись lbl из окна
...
lbl.grid(row=0, column=0)  # через некоторое время пытаемся вернуть
=> надпись снова появляется на экране
```

**3. Удаление всех виджетов в окне** - полная очистка при помощи цикла for.

Иногда нужно очистить всё окно сразу. Для этого можно перебрать список всех виджетов главного окна и уничтожить их. Для получения списка всех виджетов вы можете воспользоваться методом **winfo_children().**

Пример:
```
...
# удаляем все виджеты из окна
for widget in winfo_children():
    widget.grid_forget()

lbl.grid(row=0, column=0)  # возвращаем один из виджетов
=> видим на экране один единственный виджет - надпись lbl
```

Обратите внимание: после destroy() виджеты перестают существовать, и если вы потом захотите создать новые, это будет обычное создание заново.

--------------------------------------------------------------------------------
## Изменение виджетов в процессе работы приложения
В процессе взаимодействия пользователя с вашим приложением виджеты могут изменяться. Например, при нажатии на кнопку могут изменяться надписи (Label) в окне, или при выборе какого-либо элемента в одном списке могут изменяться элементы другого списка.

**Рассмотрим пример.** Требуется написать программу для ввода пользователем своего места проживания. 

Нам понадобится два выпадающих списка (ComboBox): для стран и для городов. А также тестовое поле (Entry) для ввода адреса проживания (улица, дом, квартира и т. д.). Причём список городов будет зависеть от страны, выбранной в списке стран. То есть нам нужно указать функцию в параметре command для списка стран и в этой функции проверять, какая страна была выбрана, а затем изменять элементы в списке городов. 

При нажатии на кнопку "Готово!" в окне нужно отобразить единственную надпись - готовый адрес (все остальные виджеты удаляются).

Решение: https://github.com/alekseewatatianawork73/Python-first-year/blob/main/ctk_address.py 

<img width="750" height="430" alt="image" src="https://github.com/user-attachments/assets/08910c09-a024-4b41-bc92-22d176b0b843" />

<img width="750" height="430" alt="image" src="https://github.com/user-attachments/assets/87f5511b-ab6a-4a76-8e32-f6972f8fa812" />

<img width="750" height="430" alt="image" src="https://github.com/user-attachments/assets/7665ae83-8d5c-46f9-b6b2-b51225d1ef4a" />

--------------------------------------------------------------------------------
